(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{166:function(t,e,a){"use strict";a.r(e);var i=a(0),s=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"compilers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compilers","aria-hidden":"true"}},[t._v("#")]),t._v(" Compilers")]),a("h2",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction","aria-hidden":"true"}},[t._v("#")]),t._v(" Introduction")]),a("h3",{attrs:{id:"compiler-vs-interpreter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compiler-vs-interpreter","aria-hidden":"true"}},[t._v("#")]),t._v(" Compiler vs Interpreter")]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Compiler")]),a("p",[t._v("A program that can read one one language - the "),a("em",[t._v("source language")]),t._v(" - and translate it into an equivalent program in another language - the "),a("em",[t._v("target language")]),t._v(".")]),a("hr"),a("ul",[a("li",[a("p",[t._v("an "),a("em",[t._v("offline")]),t._v(" step before execution")])]),a("li",[a("p",[t._v("target language could be:")]),a("ol",[a("li",[t._v("an executable file")]),a("li",[t._v("intermediate format")]),a("li",[t._v("another programming language")])])])])]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Interpreter")]),a("p",[t._v("A program that read an executable input program and produces the results of that running program.")]),a("hr"),a("ul",[a("li",[t._v("runs every time the program is executed.")])])]),a("h3",{attrs:{id:"compilation-modules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compilation-modules","aria-hidden":"true"}},[t._v("#")]),t._v(" Compilation Modules")]),a("p",[t._v("Each module produces output which serves as input to the next modules.")]),a("ol",[a("li",[a("strong",[t._v("Lexical Analyzer")]),t._v(" > "),a("em",[t._v("token stream")])]),a("li",[a("strong",[t._v("Syntax Analyzer")]),t._v(" > "),a("em",[t._v("syntax tree")])]),a("li",[a("strong",[t._v("Semantic Analyzer")]),t._v(" > "),a("em",[t._v("syntax tree")])]),a("li",[a("strong",[t._v("Intermediate Code Generator")]),t._v(" > "),a("em",[t._v("intermediate representation")])]),a("li",[a("strong",[t._v("Code Optimizer")]),t._v(" > "),a("em",[t._v("intermediate representation")])]),a("li",[a("strong",[t._v("Code Generator")]),t._v(" > "),a("em",[t._v("target machine code")])]),a("li",[a("strong",[t._v("Code Optimizer")]),t._v(" > "),a("em",[t._v("target machine code")])])]),a("h3",{attrs:{id:"qualities-of-a-good-compiler"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#qualities-of-a-good-compiler","aria-hidden":"true"}},[t._v("#")]),t._v(" Qualities of a Good Compiler")]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Qualities of a Good Compiler")]),a("ul",[a("li",[t._v("Produces correct code")]),a("li",[t._v("Compiler & it's output runs fast")]),a("li",[t._v("Output is small")]),a("li",[t._v("Compile time is proportional to the program size")]),a("li",[t._v("Consistent, predictable optimization")]),a("li",[t._v("Good debugging & diagnostic features")])])]),a("h2",{attrs:{id:"lexical-analysis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lexical-analysis","aria-hidden":"true"}},[t._v("#")]),t._v(" Lexical Analysis")]),a("p",[a("strong",[t._v("Lexical analysis")]),t._v(" is the process of reading a stream of characters and breaking them up into "),a("em",[t._v("lexemes")]),t._v(".")]),a("h3",{attrs:{id:"definitions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definitions","aria-hidden":"true"}},[t._v("#")]),t._v(" Definitions")]),a("blockquote",[a("p",[a("strong",[t._v("Lexeme")]),t._v(" - a component substring")])]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Lexeme")]),a("blockquote",[a("p",[t._v("a component substring")])]),a("ul",[a("li",[t._v("each has a token/class, e.g.) identifiers, integers, operators, etc.")]),a("li",[t._v("forms a "),a("em",[t._v("token")]),t._v(" with it's token type, e.g.) "),a("code",[t._v('<int, "0">')])])])]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Regular Expressions")]),a("ul",[a("li",[t._v("provide a formalized way of specifying the rules for describing a programming language.")]),a("li",[t._v("used to define lexeme patterns in order to determine valid lexemes.")]),a("li",[t._v("define all the possible strings in a particular lexeme token type.")])])]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Some more definitions")]),a("ul",[a("li",[a("strong",[t._v("alphabet")]),t._v(" - a finite set of symbols.")]),a("li",[a("strong",[t._v("string")]),t._v(" - a finite sequence of symbols drawn from an alphabet.")]),a("li",[a("strong",[t._v("character")]),t._v(" - a string with length 1.")]),a("li",[a("strong",[t._v("language")]),t._v(" - any set of strings over some fixed alphabet.")]),a("li",[a("strong",[t._v("regular set/language")]),t._v(" - a language that can defined using regular expressions.")]),a("li",[a("strong",[t._v("epsilon")]),t._v(" - empty string with length 0.")])])]),a("h3",{attrs:{id:"operations-on-languages"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#operations-on-languages","aria-hidden":"true"}},[t._v("#")]),t._v(" Operations on Languages")]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Union - AUB")]),a("p",[a("code",[t._v("{ e | e is an element of A or e is an element of B }")])])]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Concatenation - AB")]),a("p",[a("code",[t._v("{ ab | a is an element of A and b is an element of B }")])])]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Kleene Closure - A*")]),a("p",[a("code",[t._v("if A = { A }, then A* = { E, a, aa, aaa..}, where E = empty string")])])]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Positive Closure - A+")]),a("p",[a("code",[t._v("A+ = A.A*")])]),a("p",[a("code",[t._v("if A = { A }, then A* = { a, aa, aaa..}")])])]),a("h3",{attrs:{id:"forming-regular-expressions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#forming-regular-expressions","aria-hidden":"true"}},[t._v("#")]),t._v(" Forming Regular Expressions")]),a("h4",{attrs:{id:"phase-1-basis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#phase-1-basis","aria-hidden":"true"}},[t._v("#")]),t._v(" Phase 1: Basis")]),a("h4",{attrs:{id:"phase-2-induction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#phase-2-induction","aria-hidden":"true"}},[t._v("#")]),t._v(" Phase 2: Induction")]),a("h2",{attrs:{id:"finite-automata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#finite-automata","aria-hidden":"true"}},[t._v("#")]),t._v(" Finite Automata")]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Finite Automata")]),a("p",[a("em",[t._v("Transition graphs")]),t._v(" that recognize patterns.")]),a("hr"),a("ul",[a("li",[a("p",[t._v("used for the implementation of a language.")])]),a("li",[a("p",[t._v("can be used to express any "),a("em",[t._v("regular language")]),t._v(".")])]),a("li",[a("p",[t._v("recognizes a string if there is some path in it's transition graph from the start state to an accepting state such that the symbols along the path spell out the string.")])]),a("li",[a("p",[a("strong",[t._v("not recognized if:")])]),a("ul",[a("li",[t._v("does not end in an accepting state.")]),a("li",[t._v("gets stuck at a state with no appropritate transition.")])])])])]),a("h3",{attrs:{id:"types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#types","aria-hidden":"true"}},[t._v("#")]),t._v(" Types")]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Nondeterministic Finite Automata (NFA)")]),a("ul",[a("li",[t._v("can have "),a("em",[t._v("multiple transitions for the same input")]),t._v(" in a given state.")]),a("li",[t._v("can have "),a("code",[t._v("E")]),t._v(" moves.")]),a("li",[t._v("slower but smaller.")])])]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Deterministic Finite Automata (DFA)")]),a("ul",[a("li",[t._v("can have "),a("em",[t._v("only one transition per input")]),t._v(" per state.")]),a("li",[t._v("no "),a("code",[t._v("E")]),t._v(" moves.")]),a("li",[t._v("faster but bigger.")])])]),a("h3",{attrs:{id:"lexical-analysis-stages"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lexical-analysis-stages","aria-hidden":"true"}},[t._v("#")]),t._v(" Lexical Analysis Stages")]),a("ol",[a("li",[a("strong",[t._v("Lexical Specification")])]),a("li",[a("strong",[t._v("Regular Expressions")])]),a("li",[a("strong",[t._v("NFA")])]),a("li",[a("strong",[t._v("DFA")])]),a("li",[a("strong",[t._v("Table-based DFA Implementation")])])]),a("h3",{attrs:{id:"regex-to-nfa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regex-to-nfa","aria-hidden":"true"}},[t._v("#")]),t._v(" Regex to NFA")]),a("h3",{attrs:{id:"nfa-to-dfa"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nfa-to-dfa","aria-hidden":"true"}},[t._v("#")]),t._v(" NFA to DFA")]),a("h2",{attrs:{id:"parsing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parsing","aria-hidden":"true"}},[t._v("#")]),t._v(" Parsing")]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Parser")]),a("p",[t._v("Checks whether a program confirms to a set of grammatical rules.")]),a("hr"),a("ul",[a("li",[t._v("Accepts input tokens for the lexical analyzer, and outputs a syntax tree as input for semantic analysis.")])])]),a("h3",{attrs:{id:"context-free-grammers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context-free-grammers","aria-hidden":"true"}},[t._v("#")]),t._v(" Context Free Grammers")]),a("p",[t._v("CFGs specify programming language syntax constructs.")]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Requirements")]),a("ul",[a("li",[a("p",[a("strong",[t._v("Set of Terminals")]),a("code",[t._v("T")])]),a("ul",[a("li",[t._v("define basic strings which make up the program - "),a("strong",[t._v("token types")]),t._v(".")])])]),a("li",[a("p",[a("strong",[t._v("Set of Non-Terminals")]),a("code",[t._v("N")])]),a("ul",[a("li",[t._v("define more complex language constructs.")])])]),a("li",[a("p",[a("strong",[t._v("A Start Symbol")]),a("code",[t._v("S")])]),a("ul",[a("li",[t._v("a non-terminal which is used a starting point to generate a complete program.")])])]),a("li",[a("p",[a("strong",[t._v("A Set of Predictions")])]),a("ul",[a("li",[t._v("specify how all the non-terminals are generated with terminals or other non-terminal to form more complex constructs.")])])])])]),a("h3",{attrs:{id:"derivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#derivation","aria-hidden":"true"}},[t._v("#")]),t._v(" Derivation")]),a("ul",[a("li",[t._v("a sequence of one or more productions rules.")]),a("li",[t._v("deriving a program always starts at "),a("code",[t._v("S")]),t._v(".")])]),a("div",{staticClass:"warning custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Types of Derivation")]),a("ul",[a("li",[a("p",[a("strong",[t._v("Leftmost")])]),a("ul",[a("li",[t._v("used in "),a("em",[t._v("top down parsing.")])]),a("li",[t._v("leftmost non-terminal is always chosen for expansion.")])])]),a("li",[a("p",[a("strong",[t._v("Rightmost")])]),a("ul",[a("li",[t._v("used in "),a("em",[t._v("bottom up")]),t._v(" parsing.")]),a("li",[t._v("rightmost non-terminal is always chosen for expansion.")])])])])]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Syntax Tree")]),a("p",[t._v("Represent a derivation.")]),a("hr"),a("ul",[a("li",[a("p",[t._v("AKA Parse Tree")])]),a("li",[a("p",[t._v("an "),a("em",[t._v("in-order traversal")]),t._v(" produces the original output (TODO input?) .")])]),a("li",[a("p",[a("strong",[t._v("Components:")])]),a("ul",[a("li",[a("em",[t._v("terminals")]),t._v(" at the leaves, corresponding to tokens.")]),a("li",[a("em",[t._v("non-terminals")]),t._v(" at the interior nodes.")])])])])]),a("h2",{attrs:{id:"semantic-analysis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#semantic-analysis","aria-hidden":"true"}},[t._v("#")]),t._v(" Semantic Analysis")]),a("h2",{attrs:{id:"activation-records"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#activation-records","aria-hidden":"true"}},[t._v("#")]),t._v(" Activation Records")]),a("h2",{attrs:{id:"intermediate-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#intermediate-code","aria-hidden":"true"}},[t._v("#")]),t._v(" Intermediate Code")]),a("h2",{attrs:{id:"ir-optimization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ir-optimization","aria-hidden":"true"}},[t._v("#")]),t._v(" IR Optimization")]),a("h2",{attrs:{id:"instruction-selection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instruction-selection","aria-hidden":"true"}},[t._v("#")]),t._v(" Instruction Selection")]),a("h2",{attrs:{id:"liveness-analysis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#liveness-analysis","aria-hidden":"true"}},[t._v("#")]),t._v(" Liveness Analysis")]),a("h2",{attrs:{id:"register-allocation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#register-allocation","aria-hidden":"true"}},[t._v("#")]),t._v(" Register Allocation")])])}],!1,null,null,null);e.default=s.exports}}]);